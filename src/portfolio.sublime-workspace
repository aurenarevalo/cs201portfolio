{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"adj",
				"adjNode"
			],
			[
				"END_",
				"END_TURN_AI"
			],
			[
				"SEND",
				"SEND_UNITS_AI"
			],
			[
				"check",
				"check_units"
			],
			[
				"che",
				"check_units"
			],
			[
				"END",
				"END_TURN_PLAYER"
			],
			[
				"SEND_UNITS",
				"SEND_UNITS_PLAYER"
			],
			[
				"selec",
				"selected_node"
			],
			[
				"sele",
				"selected_node"
			],
			[
				"print",
				"printw"
			],
			[
				"game",
				"gameGrid"
			],
			[
				"button_",
				"button_win"
			],
			[
				"newwin",
				"newwin_offset"
			],
			[
				"set_menu_",
				"set_menu_win"
			],
			[
				"check_size",
				"check_size_menuList"
			],
			[
				"curr",
				"curr_indx"
			],
			[
				"tmp",
				"tmp_list"
			],
			[
				"ver",
				"vertices"
			],
			[
				"v",
				"vertices"
			],
			[
				"mov",
				"move_panel"
			],
			[
				"panel",
				"panel_array"
			],
			[
				"COL",
				"COLOR_WHITE"
			],
			[
				"new",
				"newwinOffset"
			],
			[
				"resi",
				"resizeHandler"
			],
			[
				"initialize",
				"initialize_ncurses"
			],
			[
				"cha",
				"choiceArray"
			]
		]
	},
	"buffers":
	[
		{
			"file": "main.c",
			"settings":
			{
				"buffer_size": 5135,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"gamemanager.h\"\n\nstatic unsigned int SD1 = 234234, SD2 = 21456789, SD3 = 0x7f0ce821;\n\ntypedef struct point Point;\n\ntypedef struct inode infectionNode;\n\ntypedef struct ggrid gameGrid;\n\ngameGrid* init_gameGrid(int r, int c, int nodes,PANEL* game_pan)\n{\n\t// printf(\"\\n\\n %d ROWS %d COLS %d NODES : %d possible NODES\\n\\n\\n\",r,c,nodes,r*c);\n\tgameGrid* gg = malloc(sizeof(gameGrid));\n\tgg->parent = init_intMatrix(r,c);\n\tgg->node = (infectionNode**)malloc(nodes*sizeof(infectionNode*));\n\tfor(int i=0; i<nodes; i++)\n\t\tgg->node[i] = init_infectionNode(0,-1);\n\tgg->nodes = nodes;\n\tgg->game_panel =game_pan;\n\tgg->game_graph = init_Graph(nodes);\n\treturn gg;\n\n}\n\ninfectionNode* init_infectionNode()\n{\n\tinfectionNode *node = malloc(sizeof(infectionNode));\n\tnode->control = -1;\n\tnode->units = -1;\n\tnode->pos.x = 0;\n\tnode->pos.y = 0;\n\tnode->node_but = malloc(sizeof(BUTTON));\n\tnode->al.head = NULL;\n\treturn node;\n}\n\nvoid place_node(gameGrid** grid,infectionNode* node)\n{\n\tgameGrid* ggrid = *grid;\n\tint x,y;\n\tx = node->pos.x;\n\ty = node->pos.y;\n\tggrid->parent->m[y][x] = node->control;\n\tnode->node_but = new_button(panel_window(ggrid->game_panel),y*2+1,x*3+1,2,3);\n\tif(node->control == 1){\n\t\twbkgd(button_win(node->node_but),COLOR_PAIR(7));\n\t}\n\telse if(node->control == 2)\n\t\twbkgd(button_win(node->node_but),COLOR_PAIR(5));\n\telse if(node->control == 3)\n\t\twbkgd(button_win(node->node_but),COLOR_PAIR(6));\n\tmvwprintw(button_win(node->node_but),0,0,\"%d\",node->units);\n}\n\nvoid set_node_params(infectionNode* node,int contr, int units, int x, int y)\n{\n\tnode->control = contr;\n\tnode->units = units;\n\tnode->pos.x = x;\n\tnode->pos.y = y;\n\n}\nvoid add_new_node(gameGrid** grid, int contr, int units, int x, int y)\n{\n\tgameGrid *ggrid = *grid;\n\tggrid->nodes++;\n\tggrid->node = realloc(ggrid->node,ggrid->nodes*sizeof(infectionNode));\n\tset_node_params(ggrid->node[ggrid->nodes-1],contr,units,x,y);\n\tplace_node(grid,ggrid->node[ggrid->nodes-1]);\n}\n /*\n * pseudo rng that seems to maintain a decent distribution. \n * probably can figure out, mathematically, one that will do better... but whatev\n * inspired by the KISS rng algorithm, but uses time() so the same board wont be generated at startup\n */\n\nint rng(unsigned int max,unsigned int min)\n {\t\n\tunsigned long long x;\n\tunsigned int t = time(NULL);\n\t// unsigned int m = 37;\n\t\tt ^= (t>>2); t ^= (t<<5); t^= (t<<10);\n\t\tSD1 ^= (SD1<<3); SD1^= (SD1>>8);\n\t\tSD2 ^= (SD2>>5); \n\t\tSD3 ^= (SD3>>8);\n\t\t x = (SD1*SD2 +SD3*SD1 + SD1*124567 + SD3)*t/3;\n\tint num = x%(max+1);\n\tif(num < min) return rng(max,min);\n\tprintf(\"%u\\n\",num);\t\n\treturn num;\n}\n/*\n* Finds the distance between two nodes. This is to help determine cost of movement.\n*/\nfloat find_distance(infectionNode n1, infectionNode n2)\n{\n\tfloat x1 = n1.pos.x, y1 = n1.pos.y;\n\tfloat x2 = n2.pos.x, y2 = n2.pos.y;\n\tfloat dx = x2-x1, dy = y2-y1;\n\tfloat dist = sqrt(pow(dx,2)+pow(dy,2));\n\tprintf(\"%f\\n\\n\", dist);\n\treturn dist;\n}\n\n/*\n* wow, what a function this will be\n* thinking about using a tree to store positions. easier to check \n*/\n\n/*void find_adjacencies(gameGrid *gg)\n{\n\tint r = gg->parent->r, c = gg->parent->c;\n\tint **m = gg->parent->m;\n\tfor(int i=0;i<gg->nodes;i++)\n\t{\n\t\tint y = gg->node[i]->pos.y;\n\t\tint x = gg->node[i]->pos.x;\n\t\tfor(int row=-1; row<2; row++)\n\t\t{\n\t\t\tfor(int col=-1; col<2; col++){\n\t\t\t\tint in_bounds = (((col+x) >= 0 && (col+x) <c)\n\t\t\t\t\t&& ((row+y) >=0 && (row+y) < r));\n\t\t\t\tif(in_bounds)\n\t\t\t\t{\n\t\t\t\t\tif(m[row+y][col+x] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ty=row+y\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}*/\n\nvoid add_adjacency(gameGrid** gg, int from, int to)\n{\n\tgameGrid* ggt = *gg;\n\tfloat dist = find_distance(*ggt->node[from],*ggt->node[to]);\n\tnew_edge(&ggt->game_graph,to,from,dist);\n\tnew_edge(&ggt->game_graph,from,to,dist);\n}\n\n// void connect_nodes\n\ngameGrid* generate_gameGrid(PANEL* game_pan)\n{\n\tint nrows, ncols, nodes;\n\tnrows = 7;//rng(MAX_ROWS,MIN_ROWS);\n\tncols = 7;//rng(MAX_COLS,MIN_COLS);\n\tnodes =4;// rng(MAX_NODES,MIN_NODES);\n\tgameGrid* gg = init_gameGrid(nrows,ncols,nodes,game_pan);\n\tncols--;nrows--;\n\tfor(int r=0; r<=nrows; r++){\n\t\tfor(int c=0; c<=ncols; c++){\n\t\t\tgg->parent->m[r][c] = 9;\n\t\t}\n\t}\n\t/*set_node_params(&gg->node[0],2,50,rng(ncols,0),rng(nrows,0));\n\tplace_node(&gg,gg->node[0]);\n\tset_node_params(&gg->node[1],3,50,rng(ncols,1),rng(nrows,1));\n\tplace_node(&gg,gg->node[1]);*/\n\t// add_new_node(&gg,3,50,1,1);\n\t// add_new_node(&gg,1,50,3,3);\n\t// add_new_node(&gg,2,50,5,5);\n\t// add_new_node(&gg,1,50,5,5);\n\tset_node_params(gg->node[0],2,50,5,5);\n\tplace_node(&gg,gg->node[0]);\n\tset_node_params(gg->node[1],3,50,1,1);\n\tplace_node(&gg,gg->node[1]);\n/*\tfor(int i=0; i<nodes; i++)\n\t{\n\t\tset_node_params(&gg->node[i],1,50,rng(ncols,0),rng(nrows,0));\n\t\tplace_node(&gg,gg->node[i]);\n\t\tprintf(\"%d\\n\",gg->node[i].pos.x);\n\t}*/\n\tset_node_params(gg->node[2],1,50,3,3);\n\tset_node_params(gg->node[3],2,50,5,1);\n\tplace_node(&gg,gg->node[2]);\n\tplace_node(&gg,gg->node[3]);\n\tadd_adjacency(&gg,0,3);\n\tadd_adjacency(&gg,0,2);\n\tadd_adjacency(&gg,2,1);\n\tadd_adjacency(&gg,1,3);\n\tadd_adjacency(&gg,2,3);\n\t// add_new_node(&gg,4,50,4,4);\n\t// add_new_node(&gg,4,50,2,2);\n\t// find_distance(gg->node[0],gg->node[1]);\n\n\n\treturn gg;\n}\n\n\nvoid refresh_nodes(gameGrid** gg)\n{\n\tgameGrid* ggt= *gg;\n\tfor(int i = 0; i< ggt->nodes; i++)\n\t{\t\n\t\tmvwprintw(button_win(ggt->node[i]->node_but),0,0,\"%d\",ggt->node[i]->units);\n\t\twrefresh(button_win(ggt->node[i]->node_but));\n\t}\n}\n//returns if node is a player node or not\nint is_player_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 2);\n}\n//returns if node is a neutral node or not\nint is_neutral_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 1);\n}\n\n// ALSO used for player2 identification!\nint is_enemy_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 3);\n}\n\n//Check mouse button 1 click (down) is within bounds of a button. Returns the button node.\nint mk1_check(gameGrid* gg,MEVENT me)\n{\n\t\tfor(int i = 0; i< gg->nodes; i++)\n\t\t{\n\t\t\tprintw(\" - %d  %d \", i,gg->nodes);\n\t\t\tinfectionNode* node = gg->node[i];\n\t\t\tif(is_button_press(me,node->node_but))\n\t\t\t{\n\t\t\t\t// printw(\" - %d  %d \", i,gg->nodes);\n\t\t\t\t// mvwprintw(button_win(gg->node[i]->node_but),0,0,\"%d\",gg->node[i]->units);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\treturn -1;\n}\n\n/*\n* Returns value depending on situtation\n* If units > 100, returns 1\n* if units < 0, returns 2\n* else, returns 0\n*/\nint check_units(gameGrid* gg, int node)\n{\n\tif(gg->node[node]->units >=MAX_UNITS)\n\t{\n\t\tgg->node[node]->units = MAX_UNITS;\n\t\treturn 1;\n\t}\n\tif(gg->node[node]->units <10) wclear(button_win(gg->node[node]->node_but));\n\tif (gg->node[node]->units < 0)\n\t\treturn 2;\n\treturn 0;\n}\n//changes control of node and sets color accordingly\nvoid change_control(gameGrid* gg, int node, int new_control, int overflow)\n{\n\tgg->node[node]->control = new_control;\n\tif(gg->node[node]->units < 0) gg->node[node]->units = overflow;\n\tswitch(new_control)\n\t{\n\t\tcase 2:\n\t\t\twbkgd(button_win(gg->node[node]->node_but),COLOR_PAIR(5));\n\t\tbreak;\n\t\tcase 3:\n\t\t\twbkgd(button_win(gg->node[node]->node_but),COLOR_PAIR(6));\n\t\tbreak;\n\t}\n\trefresh_nodes(&gg);\n}\n\n/*void set_units(gameGrid* gg, int node, int units)\n{\n\tgg->\n}*/\n\nint add_units(gameGrid* gg, int node, int units)\n{\n\tgg->node[node]->units += units;\n\tif(gg->node[node]->units > MAX_UNITS) return (gg->node[node]->units - MAX_UNITS);\n\treturn 0;\n\t\n\t// if()\n}\n\nint sub_units(gameGrid* gg,int node, int units)\n{\n\tgg->node[node]->units -= units;\n\tif(gg->node[node]->units< 0) return (-1*(gg->node[node]->units));\n\t\n\treturn 0;\n}\n\nvoid check_win_condition();\n\n/*enum get_game_state()\n{\n\n}*/\n\nint select_node(gameGrid *gg, MEVENT event,int control_select)\n{\n\t\n}\nvoid GAME_LOOP_AI(gameGrid* gg)\n{\n\tint input;\n\n\tGAME_STATES_AI gsai = TURN_PLAYER;\n\tmousemask(ALL_MOUSE_EVENTS,NULL);\n\tMEVENT event;\n\n/*\tNEW_GAME,\n\tSELECT_NODE_PLAYER,\n\tSELECT_NODE_AI,\n\tWEIGH_OPTIONS_AI,\n\tTURN_PLAYER,\n\tTURN_AI,\n\tSEND_UNITS_PLAYER,\n\tSEND_UNITS_AI,\n\tEND_TURN,\n\tPLAYER_WIN,\n\tAI_WIN*/\n\t\n\t/*\n\t*\tAI flow: The AI will select one of its nodes at random,\n\t*\tIt will then weigh it's options and proceed to attack\n\t*\n\t*/\n\t\n\t\n\t/*\n\t\tADD A CONFIRMATION FOR SENDING UNITS. TELL PLAYER HOW MANY TURNS IT WILL TAKE TO GET THERE.\n\t\tIF POSSIBLE ADD VISUAL SHOWING WHERE UNITS ARE.\n\t*/\n\tint units = 10;\n\tint unit_gen = 5;\n\t\n\tnodelay(panel_window(gg->game_panel),TRUE);\n\t\n\tint selected=-1, dest=-1;\n\twhile((input=wgetch(panel_window(gg->game_panel)))!=122)\n\t{\n\t\tswitch(input){\n\t\t\tdefault:\n\t\t\tcase KEY_MOUSE:\n\t\t\t\n\t\t\tif(1){\n\t\t\t\tswitch(gsai)\n\t\t\t\t{\n\t\t\t\t\tcase NEW_GAME_AI: //implement regeneration of board\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TURN_PLAYER:\n\t\t\t\t\t\twclear(stdscr);\n\t\t\t\t\t\tmvprintw(0,0,\"Player turn\");\n\t\t\t\t\t\tgsai = SELECT_NODE_PLAYER;\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TURN_AI:\n\t\t\t\t\t\twclear(stdscr);\n\t\t\t\t\t\tmvprintw(0,0,\"Computer turn\");\n\t\t\t\t\t\tgsai=SELECT_NODE_AI;\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SELECT_NODE_PLAYER:\n\t\t\t\t\t\tif(getmouse(&event) == OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tselected = mk1_check(gg,event);\n\t\t\t\t\t\t\tif(!(selected<0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(event.bstate & BUTTON1_PRESSED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintw(\" oooooo\");\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(is_player_node(gg,selected))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbox(button_win(gg->node[selected]->node_but),0,0);\n\t\t\t\t\t\t\t\t\tmvprintw(1,1,\"node %d selected\",selected);\n\t\t\t\t\t\t\t\t\tunits = gg->node[selected]->units/2;\n\t\t\t\t\t\t\t\t\tmvprintw(1,1,\"node %d selected %d\",selected, units);\n\t\t\t\t\t\t\t\t\tgsai = SEND_UNITS_PLAYER;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tmvprintw(0,0,\"Not a player node\");\n\t\t\t\t\t\t\t\t\tselected=-1;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// gsai = TURN_PLAYER;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SELECT_NODE_AI:\n\t\t\t\t\t\t// printw(\"AI thinking\")\n\t\t\t\t\t\t// napms(2000);\n\t\t\t\t\t\tgsai=WEIGH_OPTIONS_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase WEIGH_OPTIONS_AI:\n\t\t\t\t\t\tprintw(\"AI thinking\");\n\t\t\t\t\t\tnapms(2000);\n\t\t\t\t\t\tgsai=SEND_UNITS_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcase SEND_UNITS_PLAYER:\n\t\t\t\t\t\tif(getmouse(&event) == OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(event.bstate & BUTTON1_PRESSED)\n\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\tif((dest=mk1_check(gg,event))+1){\n\t\t\t\t\t\t\t\tif(check_units(gg,dest)!=1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twclear(button_win(gg->node[selected]->node_but));\n\t\t\t\t\t\t\t\tif(dest != selected){\n\t\t\t\t\t\t\t\t\tint extra_sub=0;\n\t\t\t\t\t\t\t\t\tint extra_add=0;\n\t\t\t\t\t\t\t\t\tsub_units(gg,selected,units);\n\t\t\t\t\t\t\t\t\tif(is_neutral_node(gg,dest) || is_enemy_node(gg,dest))extra_sub = sub_units(gg,dest,units);\n\t\t\t\t\t\t\t\t\tif(is_player_node(gg,dest)) extra_add = add_units(gg,dest,units);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tgsai = END_TURN_PLAYER;\n\t\t\t\t\t\t\t\t\tif(check_units(gg,dest)==2)\n\t\t\t\t\t\t\t\t\t\tchange_control(gg,dest,2,extra_sub);\n\t\t\t\t\t\t\t\t\tif(check_units(gg,dest) ==1){\n\t\t\t\t\t\t\t\t\t\tadd_units(gg,selected,extra_add);\n\t\t\t\t\t\t\t\t\t\tgg->node[dest]->units =100;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse gsai = TURN_PLAYER;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tselected = -1; dest = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SEND_UNITS_AI:\n\t\t\t\t\t\tsub_units(gg,0,10);\n\t\t\t\t\t\tgsai=END_TURN_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase END_TURN_PLAYER:\n\t\t\t\t\t\n\t\t\t\t\tfor(int i=0; i<gg->nodes;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(is_player_node(gg,i) ) {\n\t\t\t\t\t\t\t\tadd_units(gg,i,unit_gen);\n\t\t\t\t\t\t\t\tcheck_units(gg,i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tgsai = TURN_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase END_TURN_AI:\n\t\t\t\t\t\tgsai=TURN_PLAYER;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase PLAYER_WIN:\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase AI_WIN:\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\t// default:\n\t\t\n\t\t\t// break;\n\t\t\n\t\t}\n\t\trefresh_nodes(&gg);\n\t\tupdate_panels();\n\t\tdoupdate();\n\t\t// mvprintw(0,0,\"           STATE: %d\", gsai);\n\t}\n}\n\n\nvoid GAME_LOOP_LOCAL(gameGrid* gg)\n{\n\tint input;\n\n\n\t// GAME_STATES_LOCAL gsl;\n\n\twhile((input=wgetch(panel_window(gg->game_panel)))!=122)\n\t{\n\t\tswitch(input){\t\n\t\tcase KEY_MOUSE:\n\t\t/*\tswitch(gsl)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}*/\n\t\t\n\t\t\n\t\t\n\t\tbreak;\n\t\t\n\t\t}\n\t\trefresh_nodes(&gg);\n\t\tupdate_panels();\n\t\tdoupdate();\n\n\t}\n\n\n}",
			"file": "gamemanager.c",
			"file_size": 11671,
			"file_write_time": 131975741471287105,
			"settings":
			{
				"buffer_size": 11670,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <panel.h>\n\n\n#include \"infection_ds.h\"\n#include \"utility.h\"\n#include \"button.h\"\n#include \"gamestates.h\"\n\n#define MAX_UNITS 100\n#define MAX_ROWS 15\n#define MAX_COLS 15\n#define MAX_NODES 20\n\n#define MIN_UNITS 50\n#define MIN_ROWS 6\n#define MIN_COLS 6\n#define MIN_NODES 5\n\n/*\n\n\t\tINFECTION GAME GUIDELINES: \n\t\t1. No two player nodes should be directly adjacent! At least 1 neutral node in b/t\n\t\t2. Maximum connections is 8! one for each adjacent position on the grid! ( for simplicity)\n\t\t3. Each player starts at 50 units! Max is 100 units!\n\t\t4. Weight of sending costs should be calculated (ignoring loss of origin units -- add later?)\n\t\t\tbased on the DISTANCE to each node, and the UNITS within each node!\n\n\n\n\n\n\n\n\n*/\n\ntypedef struct point{\n\tint x,y;\n}Point;\n// 9 for neutral, 1 for connector vert/horiz, 2 for player 1, 3 for player 2/AI, 4 connector horiz.-- int control\ntypedef struct inode{\n\tint control;\n\tint units;\n\tPoint pos;\n\tBUTTON* node_but;\n\t// adjNode* anode;\n\tadjList al;\n}infectionNode;\n\ntypedef struct ggrid{\n\tint nodes;\n\tint n_p1,n_p2,n_neutral;\n\tintMatrix *parent;\n\tPANEL* game_panel;\n\tinfectionNode **node// printw(\"AI thinking\")\n\t\t\t\t\t\t// napms(2000);;\n\tGraph* game_graph;\n}gameGrid;\n\ngameGrid* init_gameGrid(int r, int c, int nodes,PANEL* game_pan);\n\ninfectionNode* init_infectionNode();\n\nvoid place_node(gameGrid** grid,infectionNode *node);\n\nvoid set_node_params(infectionNode* node,int contr, int units, int x, int y);\n\nvoid add_new_node(gameGrid** gg, int contr, int units, int x, int y);\n\nint rng(unsigned int max,unsigned int min);\n\nfloat find_distance(infectionNode n1, infectionNode n2);\n\n/* function that will need to be implemented, named for ideas */\n\n/*\t\n*\trandomize_adjacency(gameGrid*,...?);\n*\tplayers_not_adjacent\n*\tdraw_connections(gameGrid*,) -- calls add_new_node\n*/\n\nvoid add_adjacency(gameGrid** gg, int from, int to);\n\ngameGrid* generate_gameGrid(PANEL* game_pan);\n\nvoid refresh_nodes(gameGrid** gg);\n\nint is_player_node(gameGrid* gg, int node);\n\n//returns if node is a neutral node or not\nint is_neutral_node(gameGrid* gg, int node);\n\n\n// ALSO used for player2 identification!\nint is_enemy_node(gameGrid* gg, int node);\n\nint mk1_check(gameGrid* gg,MEVENT me);\n\nint check_units(gameGrid* gg, int node);\n\nvoid change_control(gameGrid* gg, int node, int new_control, int overflow);\n\n// void set_units(gameGrid* gg, int node, int units);\n\nint add_units(gameGrid* gg,int node, int units);\n\n\nint sub_units(gameGrid* gg,int node, int units);\n\n\nvoid GAME_LOOP_AI(gameGrid* gg);\n\nvoid GAME_LOOP_LOCAL(gameGrid* gg);\n\n",
			"file": "gamemanager.h",
			"file_size": 2563,
			"file_write_time": 131975742417525074,
			"settings":
			{
				"buffer_size": 2609,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "infection_ds.c",
			"settings":
			{
				"buffer_size": 2148,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "infection_ds.h",
			"settings":
			{
				"buffer_size": 689,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "gamestates.h",
			"settings":
			{
				"buffer_size": 465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "makefile",
			"settings":
			{
				"buffer_size": 509,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "button.c",
			"settings":
			{
				"buffer_size": 810,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/auren/projects/cs201portfolio",
		"/home/auren/projects/cs201portfolio/src",
		"/home/auren/projects/cs201portfolio/test",
		"/home/auren/projects/cs201portfolio/userlib"
	],
	"file_history":
	[
		"/home/auren/projects/cs201portfolio/src/button.h",
		"/home/auren/projects/cs201portfolio/src/splash.txt",
		"/home/auren/projects/cs201portfolio/src/scene.h",
		"/home/auren/projects/cs201portfolio/src/utility.h",
		"/home/auren/projects/cs201portfolio/src/main",
		"/home/auren/projects/cs201portfolio/src/winman.h",
		"/home/auren/projects/cs201portfolio/src/utility.c",
		"/home/auren/projects/cs201portfolio/src/scene.c",
		"/home/auren/projects/cs201portfolio/src/makefile",
		"/home/auren/projects/cs201portfolio/src/infection_ds.h",
		"/home/auren/projects/cs201portfolio/src/infection_ds.c",
		"/home/auren/projects/cs201portfolio/src/portfolio.sublime-project",
		"/home/auren/projects/cs201portfolio/src/menumanager.h",
		"/home/auren/projects/cs201portfolio/src/test.txt",
		"/home/auren/projects/cs201portfolio/src/gamemanager.c",
		"/home/auren/projects/cs201portfolio/src/main.c",
		"/home/auren/projects/cs201portfolio/src/winman.c",
		"/home/auren/projects/cs201portfolio/src/menumanager.c",
		"/home/auren/projects/cs201portfolio/src/stdlibs.txt",
		"/home/auren/projects/cs201portfolio/src/gamemanager.h",
		"/home/auren/projects/cs201portfolio/main.c",
		"/home/auren/projects/cs201portfolio/struct.c",
		"/home/auren/projects/cs201portfolio/struct.h",
		"/home/auren/projects/cs201portfolio/utility.c",
		"/home/auren/projects/cs201portfolio/utility.h",
		"/home/auren/projects/cs201portfolio/winman.c",
		"/home/auren/projects/cs201portfolio/makefile",
		"/home/auren/projects/portfolio/makefile",
		"/home/auren/projects/portfolio/keycodes.h",
		"/home/auren/projects/portfolio/menumanager.h",
		"/home/auren/projects/portfolio/menumanager.c",
		"/home/auren/projects/portfolio/test/en_US.dic",
		"/home/auren/projects/portfolio/winman.h",
		"/home/auren/projects/portfolio/winman.c",
		"/home/auren/projects/portfolio/struct.h",
		"/home/auren/projects/portfolio/struct.c",
		"/home/auren/projects/portfolio/test/aspell-en-0.50-2/README",
		"/home/auren/projects/portfolio/mainmenu.c",
		"/home/auren/projects/portfolio/test/en_US.aff",
		"/home/auren/projects/portfolio/mainmenu.h",
		"/home/auren/projects/portfolio/test/test.c",
		"/home/auren/projects/portfolio/main (copy).c",
		"/home/auren/projects/portfolio/keycodes",
		"/home/auren/projects/portfolio/struct_p.h"
	],
	"find":
	{
		"height": 57.0
	},
	"find_in_files":
	{
		"height": 134.0,
		"where_history":
		[
			"*.txt"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"gdb_run",
			"gdb_",
			"clear",
			"stdscr",
			"print",
			"game_but",
			"infection_node",
			"gg",
			"add_panel",
			"add_",
			"sc",
			"init_ene",
			"sc",
			"pl",
			"->",
			"item_items",
			"item_",
			"/*\n",
			"printf",
			"372",
			"D",
			"}\n",
			"\tSCENE* scene = malloc(sizeof(SCENE));\n\tscene->pl = init_panelList(panels);\n\tif(menus >0){\n\t\tscene->has_menus=true;\n\t\tscene->ml = init_menuList(menus);\n\t}\n\telse\n\t{\n\t\tscene->has_menus = false;\n\t\tscene->ml = NULL;\n\t}\n\treturn scene;",
			",);",
			"oh",
			"zoo",
			"oh",
			"zoo",
			".",
			"float",
			"free(",
			"free()",
			"seed",
			"\tn->n = node;\n\tn->next = NULL;\n\ttmpnode->next = n;\n\ttmplist->head = tmp2;"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"8"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": false
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5135,
						"regions":
						{
						},
						"selection":
						[
							[
								3373,
								3373
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3125.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "gamemanager.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11670,
						"regions":
						{
						},
						"selection":
						[
							[
								9562,
								9516
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 7495.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "gamemanager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2609,
						"regions":
						{
						},
						"selection":
						[
							[
								1250,
								1250
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 743.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "infection_ds.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2148,
						"regions":
						{
						},
						"selection":
						[
							[
								114,
								114
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "infection_ds.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 689,
						"regions":
						{
						},
						"selection":
						[
							[
								451,
								451
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 335.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "gamestates.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 465,
						"regions":
						{
						},
						"selection":
						[
							[
								392,
								392
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 509,
						"regions":
						{
						},
						"selection":
						[
							[
								181,
								181
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "button.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 810,
						"regions":
						{
						},
						"selection":
						[
							[
								467,
								467
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 45.0
	},
	"input":
	{
		"height": 47.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "portfolio.sublime-project",
	"replace":
	{
		"height": 106.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 305.0,
		"last_filter": "sc",
		"selected_items":
		[
			[
				"sc",
				"SCENE"
			],
			[
				"SC",
				"SCENE"
			],
			[
				"add",
				"add_panel"
			],
			[
				"add_men",
				"add_menu"
			],
			[
				"check_",
				"check_size_menuList"
			]
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 318.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
