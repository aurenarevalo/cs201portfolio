{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"game",
				"game_pan"
			],
			[
				"check",
				"check_win_condition"
			],
			[
				"chec",
				"check_win_condition"
			],
			[
				"cond",
				"check_win_condition"
			],
			[
				"has",
				"has_player"
			],
			[
				"has_",
				"has_enemy"
			],
			[
				"extra_",
				"extra_sub"
			],
			[
				"TURN_",
				"TURN_PLAYER"
			],
			[
				"select",
				"selected"
			],
			[
				"calc",
				"calc_attack_AI"
			],
			[
				"cont",
				"control"
			],
			[
				"CTRL_W_",
				"CTRL_W_SGT"
			],
			[
				"CTRL",
				"CTRL_W_SLT"
			],
			[
				"contr",
				"contr_weight"
			],
			[
				"gameG",
				"game_graph"
			],
			[
				"adj",
				"adjNode"
			],
			[
				"END_",
				"END_TURN_AI"
			],
			[
				"SEND",
				"SEND_UNITS_AI"
			],
			[
				"che",
				"check_units"
			],
			[
				"END",
				"END_TURN_PLAYER"
			],
			[
				"SEND_UNITS",
				"SEND_UNITS_PLAYER"
			],
			[
				"selec",
				"selected_node"
			],
			[
				"sele",
				"selected_node"
			],
			[
				"print",
				"printw"
			],
			[
				"button_",
				"button_win"
			],
			[
				"newwin",
				"newwin_offset"
			],
			[
				"set_menu_",
				"set_menu_win"
			],
			[
				"check_size",
				"check_size_menuList"
			],
			[
				"curr",
				"curr_indx"
			],
			[
				"tmp",
				"tmp_list"
			],
			[
				"ver",
				"vertices"
			],
			[
				"v",
				"vertices"
			],
			[
				"mov",
				"move_panel"
			],
			[
				"panel",
				"panel_array"
			],
			[
				"COL",
				"COLOR_WHITE"
			],
			[
				"new",
				"newwinOffset"
			],
			[
				"resi",
				"resizeHandler"
			],
			[
				"initialize",
				"initialize_ncurses"
			],
			[
				"cha",
				"choiceArray"
			]
		]
	},
	"buffers":
	[
		{
			"file": "main.c",
			"settings":
			{
				"buffer_size": 5539,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "gamemanager.h",
			"settings":
			{
				"buffer_size": 2723,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "gamemanager.c",
			"settings":
			{
				"buffer_size": 15527,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "r\n\tfor(int r=0; r<nrows; r++){\n\t\tfor(int c=0; c<ncols; c++){\n\t\t\tgg->parent->m[r][c] = 9;\n\t\t}\n\t}\n\tset_node_params(&gg->node[0],2,50,rng(ncols,0),rng(nrows,0));\n\tplace_node(&gg,gg->node[0]);\n\tset_node_params(&gg->node[1],3,50,rng(ncols,1),rng(nrows,1));\n\tplace_node(&gg,gg->node[1]);\n\t// add_new_node(&gg,3,50,1,1);\n\t// add_new_node(&gg,1,50,3,3);\n\t// add_new_node(&gg,2,50,5,5);\n\t// add_new_node(&gg,1,50,5,5);\n/*\tset_node_params(gg->node[0],2,50,5,5);\n\tplace_node(&gg,gg->node[0]);\n\tset_node_params(gg->node[1],3,50,1,1);\n\tplace_node(&gg,gg->node[1]);*/\n\tfor(int i=0; i<nodes; i++)\n\t{\n\t\tset_node_params(&gg->node[i],1,50,rng(ncols,0),rng(nrows,0));\n\t\tplace_node(&gg,gg->node[i]);\n\t\tprintf(\"%d\\n\",gg->node[i].pos.x);\n\t}\n\tset_node_params(gg->node[2],1,50,3,3);\n\tset_node_params(gg->node[3],1,50,5,1);\n\tplace_node(&gg,gg->node[2]);\n\tplace_node(&gg,gg->node[3]);\n\tadd_adjacency(&gg,0,3);\n\tadd_adjacency(&gg,0,2);\n\tadd_adjacency(&gg,2,1);\n\tadd_adjacency(&gg,1,3);\n\tadd_adjacency(&gg,1,2);\n\tadd_adjacency(&gg,2,3);\n\t// add_new_node(&gg,4,50,4,4);\n\t// add_new_node(&gg,4,50,2,2);\n\t// find_distance(gg->node[0],gg->node[1]);\n\n\n\treturn gg;\n}\n\n\nvoid refresh_nodes(gameGrid** gg)\n{\n\tgameGrid* ggt= *gg;\n\tfor(int i = 0; i< ggt->nodes; i++)\n\t{\t\n\t\tmvwprintw(button_win(ggt->node[i]->node_but),0,0,\"%d\",ggt->node[i]->units);\n\t\twrefresh(button_win(ggt->node[i]->node_but));\n\t}\n}\n//returns if node is a player node or not\nint is_player_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 2);\n}\n//returns if node is a neutral node or not\nint is_neutral_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 1);\n}\n\n// ALSO used for player2 identification!\nint is_enemy_node(gameGrid* gg, int node)\n{\n\treturn (gg->node[node]->control == 3);\n}\n\n//Check mouse button 1 click (down) is within bounds of a button. Returns the button node.\nint mk1_check(gameGrid* gg,MEVENT me)\n{\n\t\tfor(int i = 0; i< gg->nodes; i++)\n\t\t{\n\t\t\t// printw(\" - %d  %d \", i,gg->nodes);\n\t\t\tinfectionNode* node = gg->node[i];\n\t\t\tif(is_button_press(me,node->node_but))\n\t\t\t{\n\t\t\t\t// printw(\" - %d  %d \", i,gg->nodes);\n\t\t\t\t// mvwprintw(button_win(gg->node[i]->node_but),0,0,\"%d\",gg->node[i]->units);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\treturn -1;\n}\n\n/*\n* Returns value depending on situtation\n* If units > 100, returns 1\n* if units < 0, returns 2\n* else, returns 0\n*/\nint check_units(gameGrid* gg, int node)\n{\n\tif(gg->node[node]->units >=MAX_UNITS)\n\t{\n\t\tgg->node[node]->units = MAX_UNITS;\n\t\treturn 1;\n\t}\n\tif(gg->node[node]->units <10) wclear(button_win(gg->node[node]->node_but));\n\tif (gg->node[node]->units <= 0)\n\t\treturn 2;\n\treturn 0;\n}\n//changes control of node and sets color accordingly\nvoid change_control(gameGrid* gg, int node, int new_control, int overflow)\n{\n\tgg->node[node]->control = new_control;\n\tif(gg->node[node]->units < 0) gg->node[node]->units = overflow;\n\tswitch(new_control)\n\t{\n\t\tcase 2:\n\t\t\twbkgd(button_win(gg->node[node]->node_but),COLOR_PAIR(5));\n\t\tbreak;\n\t\tcase 3:\n\t\t\twbkgd(button_win(gg->node[node]->node_but),COLOR_PAIR(6));\n\t\tbreak;\n\t}\n\trefresh_nodes(&gg);\n}\n\n/*void set_units(gameGrid* gg, int node, int units)\n{\n\tgg->\n}*/\n\nint add_units(gameGrid* gg, int node, int units)\n{\n\tgg->node[node]->units += units;\n\tif(gg->node[node]->units > MAX_UNITS) return (gg->node[node]->units - MAX_UNITS);\n\treturn 0;\n}\n\nint sub_units(gameGrid* gg,int node, int units)\n{\n\tgg->node[node]->units -= units;\n\tif(gg->node[node]->units< 0) return (-1*(gg->node[node]->units));\n\t\n\treturn 0;\n}\n\n// if return 1, player win, if 2 enemy win, return 0 else.\nint check_win_condition(gameGrid* gg)\n{\t\n\tint size = gg->game_graph->vertices;\n\tint has_enemy=0, has_player=0;\n\tfor(int i=0; i<size; i++)\n\t{\t\n\t\t// wprintw(panel_window(gg->game_panel),\"---%d--- \",gg->node[i]->control);\n\t\tif(gg->node[i]->control == 2) has_player=1;\n\t\tif(gg->node[i]->control==3) has_enemy=1;\n\t}\n\t// wprintw(panel_window(gg->game_panel),\"-.- %d, %d -.-\",has_player,has_enemy);\n\tif(has_player && !has_enemy) return 1;\n\tif(has_enemy && !has_player) return 2;\n\t\n\treturn 0;\n}\n\n/*enum get_game_state()\n{\n\n}*/\n\nint select_node(gameGrid *gg, MEVENT event,int control_select)\n{\n\t\n}\n#define CTRL_W_P 2\n#define CTRL_W_N 1\n#define CTRL_W_SLT 4\n#define CTRL_W_SGT 10\n\n#define SU_W_GT_MAX 0.5;\n#define SU_W_GT_MID 0.75;\n#define SU_W_BASE 1;\n#define SU_W_LOW 1.5;\n\n#define DIST_W_MULT 3;\n/*  WEIGHT TABLE, subject to change\n*\tis_neutral -> 1 (priority)\n*\tis_player -> 2\n*\tis_self(AI) and < 50 units -> 4\n*\tis_self(AI) and >= 50 units -> 10\n*\t\n*\t\tSelf units ...\n*\tunits > 75 -> 0.5;\n*\tunits > 50 -> 0.75;\n*\tunits < 25 -> 1.5;\n*\n*\t\tOther units ...\n*\t units -> units\n*\n*\t\tDistance  ...\n*\tturns = Distance/sqrt(8);\n*\t\t-> turns*3\n*/\n\n// used https://www.thecrazyprogrammer.com/2014/03/dijkstra-algorithm-for-finding-shortest-path-of-a-graph.html\n// as reference\nint Djikstra(gameGrid *gg,int n,int start)\n{\n\t\n\t\n}\n\n\nfloat calc_wieghts_from_node(gameGrid *gg,int node)\n{\n\t\n}\n\nint calc_attack_AI(gameGrid* gg, int selected)\n{\n\tint V = gg->game_graph->vertices;\n\tfloat weight[V];\n\tfloat self_unit_weight;\n\tfor(int i=0; i<V; i++)\n\t\tweight[i] = 0;\n\tadjNode *curr = gg->game_graph->arr[selected].head;\n\tint n=-1;\n\twhile(curr != NULL)\n\t{\n\t\tn=curr->adj;\n\t\tint contr = gg->node[n]->control;\n\t\tint units = gg->node[n]->units;\n\t\tif(contr==1) weight[n] += CTRL_W_N;\n\t\telse if(contr==2) weight[n] += CTRL_W_P;\n\t\telse if(contr==3 && units < 50) weight[n] += CTRL_W_SLT;\n\t\telse if(contr==3 && units >= 50) weight[n] += CTRL_W_SGT;\n\t\tweight[n] += gg->node[n]->units/3;\n\t\tcurr = curr->next;\n\t}\n\tint units = gg->node[selected]->units;\n\tif(units > 75) self_unit_weight = 0.5;\n\telse if (units > 50) self_unit_weight = 0.75;\n\telse if (units <= 25) self_unit_weight = 1.5;\n\telse self_unit_weight = 1;\n\tint min=weight[0];\n\tfor(int i=1; i<V; i++){ \n\t\tif(min == 0 || weight[i] < min) min =weight[i];\n\t\tweight[i] *= self_unit_weight;\n\t\tprintf(\"%f\\n\",weight[i]);\n\t}\n\tint minindx = binary_search(weight,V,min);\n\t// printf(\"\\n%d\",minindx);\n\n\treturn minindx;\n\t\n}\nvoid GAME_LOOP_AI(gameGrid* gg)\n{\n\tint input;\n\n\tGAME_STATES_AI gsai = TURN_PLAYER;\n\tmousemask(ALL_MOUSE_EVENTS,NULL);\n\tMEVENT event;\n\n/*\tNEW_GAME,\n\tSELECT_NODE_PLAYER,\n\tSELECT_NODE_AI,\n\tWEIGH_OPTIONS_AI,\n\tTURN_PLAYER,\n\tTURN_AI,\n\tSEND_UNITS_PLAYER,\n\tSEND_UNITS_AI,\n\tEND_TURN,\n\tPLAYER_WIN,\n\tAI_WIN*/\n\t\n\t/*\n\t*\tAI flow: The AI will select one of its nodes at random,\n\t*\tIt will then weigh it's options and proceed to attack\n\t*\n\t*/\n\t\n\t\n\t/*\n\t\tADD A CONFIRMATION FOR SENDING UNITS. TELL PLAYER HOW MANY TURNS IT WILL TAKE TO GET THERE.\n\t\tIF POSSIBLE ADD VISUAL SHOWING WHERE UNITS ARE.\n\t*/\n\tint units = 10;\n\tint unit_gen = 5;\n\t\n\tnodelay(panel_window(gg->game_panel),TRUE);\n\t\n\tint selected=-1, dest=-1;\n\twhile((input=wgetch(panel_window(gg->game_panel)))!=122)\n\t{\n\t\tswitch(input){\n\t\t\tdefault:\n\t\t\tcase KEY_MOUSE:\n\t\t\t\n\t\t\tif(1){\n\t\t\t\tswitch(gsai)\n\t\t\t\t{\n\t\t\t\t\tcase NEW_GAME_AI: //implement regeneration of board\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TURN_PLAYER:\n\t\t\t\t\t\twclear(stdscr);\n\t\t\t\t\t\t//something useless\n\t\t\t\t\t\t// mvprintw(0,0,\"Player turn\");\n\t\t\t\t\t\tgsai = SELECT_NODE_PLAYER;\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TURN_AI:\n\t\t\t\t\t\twclear(stdscr);\n\t\t\t\t\t\t// mvprintw(0,0,\"Computer turn\");\n\t\t\t\t\t\tgsai=SELECT_NODE_AI;\n\t\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SELECT_NODE_PLAYER:\n\t\t\t\t\t\tif(getmouse(&event) == OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tselected = mk1_check(gg,event);\n\t\t\t\t\t\t\tif(!(selected<0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(event.bstate & BUTTON1_PRESSED)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// printw(\" oooooo\");\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(is_player_node(gg,selected))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbox(button_win(gg->node[selected]->node_but),0,0);\n\t\t\t\t\t\t\t\t\t// mvprintw(1,1,\"node %d selected\",selected);\n\t\t\t\t\t\t\t\t\tunits = gg->node[selected]->units/2;\n\t\t\t\t\t\t\t\t\t// mvprintw(1,1,\"node %d selected %d\",selected, units);\n\t\t\t\t\t\t\t\t\tgsai = SEND_UNITS_PLAYER;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t// mvprintw(0,0,\"Not a player node\");\n\t\t\t\t\t\t\t\t\tselected=-1;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// gsai = TURN_PLAYER;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SELECT_NODE_AI:\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(!is_enemy_node(gg,(selected = rng(gg->nodes-1,0))) && !check_win_condition(gg));\n\t\t\t\t\t\tunits = gg->node[selected]->units/2;\n\t\t\t\t\t\tgsai=WEIGH_OPTIONS_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase WEIGH_OPTIONS_AI:\n\t\t\t\t\t\tprintw(\"AI thinking\");\n\t\t\t\t\t\t// napms(2000);\n\t\t\t\t\t\tdest = calc_attack_AI(gg,selected);\n\t\t\t\t\t\tgsai=SEND_UNITS_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SEND_UNITS_PLAYER:\n\t\t\t\t\t\tif(getmouse(&event) == OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(event.bstate & BUTTON1_PRESSED)\n\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\tif((dest=mk1_check(gg,event))+1){\n\t\t\t\t\t\t\t\tif(check_units(gg,dest)!=1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twclear(button_win(gg->node[selected]->node_but));\n\t\t\t\t\t\t\t\tif(dest != selected){\n\t\t\t\t\t\t\t\t\tint extra_sub=0;\n\t\t\t\t\t\t\t\t\tint extra_add=0;\n\t\t\t\t\t\t\t\t\tsub_units(gg,selected,units);\n\t\t\t\t\t\t\t\t\tif(is_neutral_node(gg,dest) || is_enemy_node(gg,dest))extra_sub = sub_units(gg,dest,units);\n\t\t\t\t\t\t\t\t\tif(is_player_node(gg,dest)) extra_add = add_units(gg,dest,units);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tgsai = END_TURN_PLAYER;\n\t\t\t\t\t\t\t\t\tif(check_units(gg,dest)==2)\n\t\t\t\t\t\t\t\t\t\tchange_control(gg,dest,2,extra_sub);\n\t\t\t\t\t\t\t\t\tif(check_units(gg,dest) ==1){\n\t\t\t\t\t\t\t\t\t\tadd_units(gg,selected,extra_add);\n\t\t\t\t\t\t\t\t\t\tgg->node[dest]->units =100;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse gsai = TURN_PLAYER;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tgsai=TURN_PLAYER;\n\t\t\t\t\t\t\t\t\twclear(button_win(gg->node[selected]->node_but));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tselected = -1; dest = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// gsai=TURN_PLAYER;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SEND_UNITS_AI:\n\t\t\t\t\t\n\t\t\t\t\t\t// int extra_sub=0;\n\t\t\t\t\t\t// int extra_add=0;\n\t\t\t\t\t\tsub_units(gg,selected,units);\n\t\t\t\t\t\tint extra_add, extra_sub;\n\t\t\t\t\t\tif(is_neutral_node(gg,dest) || is_player_node(gg,dest))extra_sub = sub_units(gg,dest,units);\n\t\t\t\t\t\tif(is_enemy_node(gg,dest)) extra_add = add_units(gg,dest,units);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t// gsai = END_TURN_PLAYER;\n\t\t\t\t\t\tif(check_units(gg,dest)==2)\n\t\t\t\t\t\t\tchange_control(gg,dest,3,extra_sub);\n\t\t\t\t\t\tif(check_units(gg,dest) ==1){\n\t\t\t\t\t\t\tadd_units(gg,selected,extra_add);\n\t\t\t\t\t\t\tgg->node[dest]->units =100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgsai=END_TURN_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase END_TURN_PLAYER:\n\t\t\t\t\t\n\t\t\t\t\tfor(int i=0; i<gg->nodes;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(is_player_node(gg,i) ) {\n\t\t\t\t\t\t\t\tadd_units(gg,i,unit_gen);\n\t\t\t\t\t\t\t\tcheck_units(gg,i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint win1= check_win_condition(gg);\n\t\t\t\t\t\tif(win1 == 2)\n\t\t\t\t\t\t\tgsai=AI_WIN;\n\t\t\t\t\t\telse if(win1 == 1)\n\t\t\t\t\t\t\tgsai=PLAYER_WIN;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgsai=TURN_AI;\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase END_TURN_AI:\n\t\t\t\t\t\tfor(int i=0; i<gg->nodes;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(is_enemy_node(gg,i) ) {\n\t\t\t\t\t\t\t\tadd_units(gg,i,unit_gen);\n\t\t\t\t\t\t\t\tcheck_units(gg,i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint win2= check_win_condition(gg);\n\t\t\t\t\t\tif(win2 == 2)\n\t\t\t\t\t\t\tgsai=AI_WIN;\n\t\t\t\t\t\telse if(win2 == 1)\n\t\t\t\t\t\t\tgsai=PLAYER_WIN;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgsai=TURN_PLAYER;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase PLAYER_WIN:\n\t\t\t\t\t\tmvprintw(0,0,\"PLAYER WIN!\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase AI_WIN:\n\t\t\t\t\t\tmvprintw(0,0,\"AI WIN!\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\t// default:\n\t\t\n\t\t\t// break;\n\t\t\n\t\t}\n\t\trefresh_nodes(&gg);\n\t\tupdate_panels();\n\t\tdoupdate();\n\t\t// mvprintw(0,0,\"           STATE: %d\", gsai);\n\t}\n}\n\n\nvoid GAME_LOOP_LOCAL(gameGrid* gg)\n{\n\tint input;\n\n\n\t// GAME_STATES_LOCAL gsl;\n\n\twhile((input=wgetch(panel_window(gg->game_panel)))!=122)\n\t{\n\t\tswitch(input){\t\n\t\tcase KEY_MOUSE:\n\t\t/*\tswitch(gsl)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}*/\n\t\t\n\t\t\n\t\t\n\t\tbreak;\n\t\t\n\t\t}\n\t\trefresh_nodes(&gg);\n\t\tupdate_panels();\n\t\tdoupdate();\n\n\t}\n\n\n}",
			"settings":
			{
				"buffer_size": 11344,
				"line_ending": "Unix"
			}
		},
		{
			"file": "infection_ds.c",
			"settings":
			{
				"buffer_size": 2179,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "infection_ds.h",
			"settings":
			{
				"buffer_size": 697,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "utility.c",
			"settings":
			{
				"buffer_size": 1754,
				"line_ending": "Unix"
			}
		},
		{
			"file": "utility.h",
			"settings":
			{
				"buffer_size": 276,
				"line_ending": "Unix"
			}
		},
		{
			"file": "gamestates.h",
			"settings":
			{
				"buffer_size": 465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "makefile",
			"settings":
			{
				"buffer_size": 509,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "button.c",
			"settings":
			{
				"buffer_size": 810,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/auren/projects/cs201portfolio",
		"/home/auren/projects/cs201portfolio/src",
		"/home/auren/projects/cs201portfolio/userlib"
	],
	"file_history":
	[
		"/home/auren/projects/cs201portfolio/src/gamemanager.c",
		"/home/auren/projects/cs201portfolio/src/button.h",
		"/home/auren/projects/cs201portfolio/src/splash.txt",
		"/home/auren/projects/cs201portfolio/src/scene.h",
		"/home/auren/projects/cs201portfolio/src/utility.h",
		"/home/auren/projects/cs201portfolio/src/main",
		"/home/auren/projects/cs201portfolio/src/winman.h",
		"/home/auren/projects/cs201portfolio/src/utility.c",
		"/home/auren/projects/cs201portfolio/src/scene.c",
		"/home/auren/projects/cs201portfolio/src/makefile",
		"/home/auren/projects/cs201portfolio/src/infection_ds.h",
		"/home/auren/projects/cs201portfolio/src/infection_ds.c",
		"/home/auren/projects/cs201portfolio/src/portfolio.sublime-project",
		"/home/auren/projects/cs201portfolio/src/menumanager.h",
		"/home/auren/projects/cs201portfolio/src/test.txt",
		"/home/auren/projects/cs201portfolio/src/main.c",
		"/home/auren/projects/cs201portfolio/src/winman.c",
		"/home/auren/projects/cs201portfolio/src/menumanager.c",
		"/home/auren/projects/cs201portfolio/src/stdlibs.txt",
		"/home/auren/projects/cs201portfolio/src/gamemanager.h",
		"/home/auren/projects/cs201portfolio/main.c",
		"/home/auren/projects/cs201portfolio/struct.c",
		"/home/auren/projects/cs201portfolio/struct.h",
		"/home/auren/projects/cs201portfolio/utility.c",
		"/home/auren/projects/cs201portfolio/utility.h",
		"/home/auren/projects/cs201portfolio/winman.c",
		"/home/auren/projects/cs201portfolio/makefile",
		"/home/auren/projects/portfolio/makefile",
		"/home/auren/projects/portfolio/keycodes.h",
		"/home/auren/projects/portfolio/menumanager.h",
		"/home/auren/projects/portfolio/menumanager.c",
		"/home/auren/projects/portfolio/test/en_US.dic",
		"/home/auren/projects/portfolio/winman.h",
		"/home/auren/projects/portfolio/winman.c",
		"/home/auren/projects/portfolio/struct.h",
		"/home/auren/projects/portfolio/struct.c",
		"/home/auren/projects/portfolio/test/aspell-en-0.50-2/README",
		"/home/auren/projects/portfolio/mainmenu.c",
		"/home/auren/projects/portfolio/test/en_US.aff",
		"/home/auren/projects/portfolio/mainmenu.h",
		"/home/auren/projects/portfolio/test/test.c",
		"/home/auren/projects/portfolio/main (copy).c",
		"/home/auren/projects/portfolio/keycodes",
		"/home/auren/projects/portfolio/struct_p.h"
	],
	"find":
	{
		"height": 41.0
	},
	"find_in_files":
	{
		"height": 134.0,
		"where_history":
		[
			"*.txt"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"game_grid",
			"return NULL;",
			"gdb_run",
			"gdb_",
			"clear",
			"stdscr",
			"print",
			"game_but",
			"infection_node",
			"gg",
			"add_panel",
			"add_",
			"sc",
			"init_ene",
			"sc",
			"pl",
			"->",
			"item_items",
			"item_",
			"/*\n",
			"printf",
			"372",
			"D",
			"}\n",
			"\tSCENE* scene = malloc(sizeof(SCENE));\n\tscene->pl = init_panelList(panels);\n\tif(menus >0){\n\t\tscene->has_menus=true;\n\t\tscene->ml = init_menuList(menus);\n\t}\n\telse\n\t{\n\t\tscene->has_menus = false;\n\t\tscene->ml = NULL;\n\t}\n\treturn scene;",
			",);",
			"oh",
			"zoo",
			"oh",
			"zoo",
			".",
			"float",
			"free(",
			"free()",
			"seed",
			"\tn->n = node;\n\tn->next = NULL;\n\ttmpnode->next = n;\n\ttmplist->head = tmp2;"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"8"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": false
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5539,
						"regions":
						{
						},
						"selection":
						[
							[
								1925,
								1925
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2970.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "gamemanager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2723,
						"regions":
						{
						},
						"selection":
						[
							[
								2446,
								2446
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 664.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "gamemanager.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15527,
						"regions":
						{
						},
						"selection":
						[
							[
								6643,
								6643
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4830.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11344,
						"regions":
						{
						},
						"selection":
						[
							[
								10662,
								10662
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8421.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "infection_ds.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2179,
						"regions":
						{
						},
						"selection":
						[
							[
								1801,
								1801
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 557.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "infection_ds.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 697,
						"regions":
						{
						},
						"selection":
						[
							[
								599,
								599
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 48.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "utility.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1754,
						"regions":
						{
						},
						"selection":
						[
							[
								1125,
								1125
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 660.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "utility.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 276,
						"regions":
						{
						},
						"selection":
						[
							[
								208,
								208
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "gamestates.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 465,
						"regions":
						{
						},
						"selection":
						[
							[
								20,
								20
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 509,
						"regions":
						{
						},
						"selection":
						[
							[
								399,
								399
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "button.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 810,
						"regions":
						{
						},
						"selection":
						[
							[
								340,
								340
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 29.0
	},
	"input":
	{
		"height": 47.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "portfolio.sublime-project",
	"replace":
	{
		"height": 54.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 305.0,
		"last_filter": "sc",
		"selected_items":
		[
			[
				"sc",
				"SCENE"
			],
			[
				"SC",
				"SCENE"
			],
			[
				"add",
				"add_panel"
			],
			[
				"add_men",
				"add_menu"
			],
			[
				"check_",
				"check_size_menuList"
			]
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 234.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
